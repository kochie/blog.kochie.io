---
title: Never, Ever Make Recursive Lambda Calls
tags:
  - development
keywords:
  - aws
  - lambda
  - recursion
author: kochie
jumbotron:
  src: image.png
  alt: Cloud Engineer realising their lambda function is recursing
blurb:
  I’m not sure why this still needs repeating, but please—stop writing recursive
  Lambdas.
publishedDate: 2025-07-24T21:30:00+10:00
# editedDate: 2025-03-13T21:30:00+10:00
---

I was scrolling on Linkedin the other day when I came across this click-baited
sponsored post and while this seems like useful advice for setting appropriate
retry limits it doesn't address the main issue which is recusion is bad -
especially in the cloud.

{

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <LinkedInEmbed
    url="https://www.linkedin.com/embed/feed/update/urn:li:share:7344260173496025091"
    height="573"
    width="700"
  />
</div>
}

This got me thinking about Lambda best practices and how said functions should
be used. I think due to a general lack of education and "vibe coding" people
have built exessivly complicated lambda workflows to solve a myriad of problems.
A common example I've seen around are lambda functions that invoke themself.

The issue has only gotten worse over the years, to the point where AWS has even
[created a custom tool](https://docs.aws.amazon.com/lambda/latest/dg/invocation-recursion.html)
to detect invocation recursion but that still hasn't deterred people from making
this common mistake - so I guess it's time to complain about it.

<Video
  src="/spongebob_centered_lines.mp4"
  style={{ maxWidth: 400, marginTop: 50, marginBottom: 50, borderRadius: 12 }}
  autoPlay
  loop
  muted
/>

I've done a quick search on the usual suspect sites - Linkedin and X - and
besides the fact that everyones posts are just copies of each other there are
still a few people promoting recursive workflows.

{

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <Tweet id="1285121364685254656" />
</div>
}

I'm not sure why recursion has emereged as valid cloud computing paradigm. I
think it has a lot to do with recursion not being properly taught or engineers
not having been explained the dangers in using recursion.

<Quote>
  You absolutely should not write a lambda function that calls itself.
</Quote>

Cloud costs make it counter-intuative to use lambda functions in this fashion.
Lambdas are a tool that should be used when you have a short compute processes
or asynchronous job (such as uploading files or writing to a database) and the
frequency of the job does not warrent a full time compute resource like a
container or instance.

Recursion is taught in Computer Science/Software Engineering fairly early as a
paradigm to solve complicated tasks by reducing the size of the input. But as
you can see with this example it can be incredibly expensive from a resource
perspective to compute an answer using recursion. In this fibannaci code a
lambda function essentially does one multiplicaiton operation per
invocation[^1].

```python
import boto3
import json
import os

lambda_client = boto3.client('lambda')

def lambda_handler(event, context):
    n = event.get('n', 1)
    accumulator = event.get('accumulator', 1)

    if n <= 1:
        return {
            'result': accumulator
        }

    # Prepare next payload for recursive call
    next_event = {
        'n': n - 1,
        'accumulator': accumulator * n
    }

    # Invoke this Lambda function recursively
    response = lambda_client.invoke(
        FunctionName=os.environ['AWS_LAMBDA_FUNCTION_NAME'],
        InvocationType='RequestResponse',
        Payload=json.dumps(next_event)
    )

    # Read and return the result from the recursive call
    result_payload = json.load(response['Payload'])
    return result_payload
```

So why shouldn't lambda functions call other lambda functions? There are two
main reasons in my opinion.

- Since lambda's are charged per invocation the time it takes to invoke and run
  a function can quickly eat into your budget. Even though you aren't charged
  for spinning up the lambda if your code is written in such a way that the
  first lambda has to wait for the second one you will need to pay for that wait
  time, this is a waste of both time and money.
- Lambda's should not be responsible for their own execution.

Recursive lambdas are also an indication in my opinion of poorly written code
and badly defined requirements.

Nearly all recursive functions can be transformed to a non recurisve form so
it's unlikely that what you're trying to do is a fundamentally recursive
problem. That being said there are truely recursive operations - however if your
code cannot escape using recursion you should be running it in one lambda. This
Computerphile video explains one example of a non primate recursive function.

{

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/i7sm9dzFtEI?si=NzRQysLqYGse4xaw"
    title="YouTube video player"
    // frameBorder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerPolicy="strict-origin-when-cross-origin"
    allowFullScreen
  ></iframe>
</div>
}

If you need retry logic or some type of loop you should use a step function or
SQS queue to handle the state as these systems are designed to handle edge cases
much better than your code.

I've talked about
[the power of step functions in the past](/articles/10-hpc-with-step-functions),
in my opinion they are the optimal choice when creating complicated workflows
using lambda functions.

## Don't believe me - here's a real world example

Years ago when I worked at AWS one of the new grads had to create a project for
their onboarding, as part of the project they created a recursive lambda
function that quickly spiralled out of control. This was either before lambda
concurrency limits or the default limit was set very high.

![Billing dashboard after a runaway Lambda event](9A94FC69-BEAF-409A-ABC5-1ADA41CEBEFD_1_105_c.jpeg?width=1056&height=744)

The good news for this Cloud Architect was that since this was running in an
internal account the actual costs are much lower. But if this was an external
customer account there is absolutely nothing that could of prevented this from
happening at the time.

What people might find really interesting here is how auxillary services such as
KMS, CloudTrail, and CloudWatch take up significant costs as well as the Lambda.
This is because by default these services are enabled in a somewhat noisy
configuration so when a Lambda function runs it will log activity to CloudWatch,
API calls will be logged in CloudTrail, and KMS will be used if there are any
encryption keys required. CloudWatch is notorious for cost overruns becuase most
of the time it's free or almost free, but after you pass the free tier limit the
costs quickly skyrocket.

---

[^1]:
    This is an especially henious example because the lambda needs to wait for
    all the nested lambdas to complete before it can return a result. This means
    that the time the first lambda is running for is the sum of all the nested
    functions, and the time of the second is the sum of all the below functions
    and so on.
