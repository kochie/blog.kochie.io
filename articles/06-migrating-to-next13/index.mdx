---
title: >
  Migrating to Next.js 13
blurb: >
  How did a startup from Melbourne become one of Australia's biggest banks?
tags:
  - technology
  - business
  - 100DTO
author: kochie
jumbotron:
  src: prism-dark.png
  alt: Up Banner
# publishedDate: 2022-10-20T18:00:00+11:00
publishedDate: 2022-11-13T11:00:00+11:00
---

Over the last couple of weeks I've been updating this blog to use the new
[layouts system in Next.js 13](https://beta.nextjs.org/docs/routing/fundamentals).
With the publication of this post I am very excited to announce that this site
is running completly on next.js 13 and server components via vercel edge
functions.

It's been an interesting refactor and while the official
[upgrade guide](https://beta.nextjs.org/docs/upgrade-guide) covers a lot of the
basics, there are still some gotchas that can trip you up. I'm going to document
all the issues I had migration to Next.js 13 and how I solved them.

## Installing the latest version of Next.js

To start with I followed the same steps in the upgrade guide, I installed the
latest version of next and react via npm.

```bash
npm i next@latest react@latest react-dom@latest
```

## Running Codemods for latest functionality

After this the next step is to upgrade to the latest features in the built in
components like `Link` and `Image`. Next has a tool called `codemod` that will
scan yur entire project looking for updates that need to be applied to use the
new features.

> You do need to commit any changes before running a codemod command otherwise
> it will not work.

```bash
npx @next/codemod next-image-to-legacy-image .
```

Additionally if you want the new `Image` funcitonality you can run the following

```bash
npx @next/codemod next-image-experimental .
```

replace all instances of `next/future/image` with `next/image`

```bash
sed -i '' 's/next\/future\/image/next\/image/g' ./src/**/*.tsx
```

replace all links

```bash
npx @next/codemod new-link ./src
```

layouts

```
Warning: Only plain objects can be passed to Client Components from Server Components. global objects are not supported.
  <>{</>}{</>}{</>}</>
         ^^^^^
Warning: Only plain objects can be passed to Client Components from Server Components. global objects are not supported.global
TypeError: Converting circular structure to JSON
    --> starting at object with constructor 'global'
    --- property 'global' closes the circle

```

next-seo

font-awesome

Tailwindcss

`'./src/app/**/*.{js,ts,jsx,tsx}',`

## Fathom Analytics

I'm using [Fathom Analytics](https://usefathom.com/) to track pageviews on this
site and I've had to make a few changes for it to work. Originally the way to
use it was
[well documented](https://vercel.com/guides/deploying-nextjs-using-fathom-analytics-with-vercel)
but now with the new layouts system the `useRouter` hook that this solution
depends on doesn't work anymore. The solution I've found is to create a client
component in the root layout that updates when a new layout path has changed.

```tsx{}[LineNumbers]
'use client'
import { load, trackPageview } from 'fathom-client'
import { useEffect } from 'react'
import { usePathname, useSearchParams } from 'next/navigation'

export default function Fathom() {
  const pathname = usePathname()
  const searchParams = useSearchParams()

  useEffect(() => {
    load('XXXXXXXX', {
      includedDomains: ['blog.kochie.io'],
      spa: 'auto',
    })

    trackPageview()
  }, [usePathname, useSearchParams])

  return null
}
```

This client component is loaded on the initial page load and the hook will fire
when the path changes or parameters change.

OpenGraph

## MDX Rendering

Initally I was stuck on how I would implement mdx rendering with the new system.
Previously I was using `next-mdx-renderer` which seemed to break on the latest
version. But there was a trick I saw [shadcn](https://twitter.com/shadcn) use in
their latest app [taxonomy](https://github.com/shadcn/taxonomy) that helped me
fix the issues I was facing. See with the new split of server and client react
components you have to decide what parts of the interface should be built in the
clients browser.

By creating a wrapper around the `MDXRemote` component I was able to make the
mdx render on the client side and not the server. This is a pattern I've used
throughout the project and it's quite useful.

```tsx
'use client'

import { MDXRemote, type MDXRemoteProps } from 'next-mdx-remote'
import * as components from './components'
import React from 'react'

export const MDXContent = (props: MDXRemoteProps) => {
  return <MDXRemote {...props} components={components} />
}
```

refactoring

## Should you refactor to use server components?

For the amount of work required and the number of bugs and compatibility issues,
I would say no. The reality is that the new layouts system is still in beta and
even vercel does not suggest running in produciton.

If you're working on a new site I think it's worth using instead of the old
pages setup but refactoring old sites is not really needed, I haven't seen a
significant speed increase in my static site.
