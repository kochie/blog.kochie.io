---
title: >
  Migrating to Next.js 13
blurb: >
  Sometimes migrating to a new version isn't worth it, I document all the issues
  I ran into when migrating to Next.js 13.
tags:
  - technology
  - business
  - 100DTO
author: kochie
jumbotron:
  src: prism-dark.png
  alt: Dark prism
# publishedDate: 2022-10-20T18:00:00+11:00
publishedDate: 2022-11-13T11:00:00+11:00
---

Over the last couple of weeks I've been updating this blog to use the new
[layouts system in Next.js 13](https://beta.nextjs.org/docs/routing/fundamentals).
With the publication of this post I am very excited to announce that this site
is running completly on next.js 13 and server components via vercel edge
functions.

It's been an interesting refactor and while the official
[upgrade guide](https://beta.nextjs.org/docs/upgrade-guide) covers a lot of the
basics, there are still some gotchas that can trip you up. I'm going to document
all the issues I had migration to Next.js 13 and how I solved them.

## Installing the latest version of Next.js

To start with I followed the same steps in the upgrade guide, I installed the
latest version of next and react via npm.

```bash
npm i next@latest react@latest react-dom@latest
```

This went fine and without a hitch.

## Running Codemods for latest functionality

After this the next step is to upgrade to the latest features in the built in
components like `Link` and `Image`. Next has a tool called `codemod` that will
scan your entire project looking for updates that need to be applied to use the
new features.

> You do need to commit any changes before running a codemod command otherwise
> it will not work.

The first step is to convert all `next/image` imports into `next/legacy/image`
imports as version 13 of next.js has a new image component that breaks some
functionality with the old component.

```bash
npx @next/codemod next-image-to-legacy-image .
```

Additionally if you want the new `Image` funcitonality you can run the following
codemod to update all `Image` components to the new one.

```bash
npx @next/codemod next-image-experimental .
```

Now this _should_ not break any images you have on your page, but there's no
guarantee depending on how you setup the page.

Finally you can update any `Link` components to use the new functionality where
they don't need an `a` tag inside them.

```bash
npx @next/codemod new-link .
```

Now I found that most of these codemods worked fine, but there were some edge
cases where the updates didn't di what I expected so make sure you manually
check to see what the difference these codemods perform.

## Layouts

Of course the big new feature of the new version of next is the `app` directory
which uses a completly new layout system. Now it's possible to

```
Warning: Only plain objects can be passed to Client Components from Server Components. global objects are not supported.
  <>{</>}{</>}{</>}</>
         ^^^^^
Warning: Only plain objects can be passed to Client Components from Server Components. global objects are not supported.global
TypeError: Converting circular structure to JSON
    --> starting at object with constructor 'global'
    --- property 'global' closes the circle

```

## font-awesome

## Tailwindcss

Tailwind is fortunately pretty easy to update, all you need to do is change the
`content` property in your `tailwind.config.js` file to the following.

```js
module.exports = {
  content: ['./src/app/**/*.{js,ts,jsx,tsx}'],
}
```

## Fathom Analytics

I'm using [Fathom Analytics](https://usefathom.com/) to track pageviews on this
site and I've had to make a few changes for it to work. Originally the way to
use it was
[well documented](https://vercel.com/guides/deploying-nextjs-using-fathom-analytics-with-vercel)
but now with the new layouts system the `useRouter` hook that this solution
depends on doesn't work anymore. The solution I've found is to create a client
component in the root layout that updates when a new layout path has changed.

```tsx{}[LineNumbers]
'use client'
import { load, trackPageview } from 'fathom-client'
import { useEffect } from 'react'
import {
  usePathname,
  // useSearchParams
} from 'next/navigation'

export default function Fathom() {
  const pathname = usePathname()
  // const searchParams = useSearchParams()

  useEffect(() => {
    load('XXXXXXXX', {
      includedDomains: ['blog.kochie.io'],
      spa: 'auto',
    })

    trackPageview()
  }, [usePathname])

  return null
}
```

This client component is loaded on the initial page load and the hook will fire
when the path changes or parameters change.

## OpenGraph and SEO

OpenGraph is a bit interesting, I'm using the `next-seo` package to generate
most of the SEO tags for my page but I still need to use my puppeteer script
that builds the images for web previews. Vercel has a new package called
`@vercel/og` which uses edge functions to generate the images on the fly but
I've found it buggy and unstable for my use case, hopefully in time the
performance of the pacakge will improve.

## MDX Rendering

Initally I was stuck on how I would implement mdx rendering with the new system.
Previously I was using `next-mdx-renderer` which seemed to break on the latest
version. But there was a trick I saw [shadcn](https://twitter.com/shadcn) use in
their latest app [taxonomy](https://github.com/shadcn/taxonomy) that helped me
fix the issues I was facing. See with the new split of server and client react
components you have to decide what parts of the interface should be built in the
clients browser.

By creating a wrapper around the `MDXRemote` component I was able to make the
mdx render on the client side and not the server. This is a pattern I've used
throughout the project and it's quite useful.

```tsx
'use client'

import { MDXRemote, type MDXRemoteProps } from 'next-mdx-remote'
import * as components from './components'
import React from 'react'

export const MDXContent = (props: MDXRemoteProps) => {
  return <MDXRemote {...props} components={components} />
}
```

I don't exactly like this solution, mainly because it would be more efficient
for the mdx to be compiled and rendered on the server side and only required
client components sent down the wire, but for now it seems to works.

## Should you refactor to use server components?

For the amount of work required and the number of bugs and compatibility issues,
I would say no. The reality is that the new layouts system is still in beta and
even vercel does not suggest running in produciton.

If you're working on a new site I think it's worth using instead of the old
pages setup but refactoring old sites is not really needed, I haven't seen a
significant speed increase in my static site.
