---
title: Learning Front-End Web Development in 2020
tags:
  - software
  - frontend
author: kochie
jumbotron:
  src: ferenc-almasi-eYpcLDXHVb0-unsplash.jpg
  alt: code
blurb: "Web Development has come a long way since I started playing around with html and JS. If I was starting again today here's what I'd do."
publishedDate: 2021-05-30
---

Outline

- Briefly - what do I mean by front end web development
- How has it changed over the last few years
- What are the common pitfalls
- Tools and structure

Front-End software development is normally discussed in the context of websites, however front-end is a generic term that can really be used to describe the presentation layer of any software stack, including mobile and desktop apps. In this post I'll be referring to websites.

A lot has happened in the internet these past few years. When I started learning web development ES6 had just been released and most browsers were slowly introducing new features like arrow functions and classes. Coming from a Python background these new pieces of syntactic sugar were a much needed reprieve from the confusing landscape of event loops, callbacks, and asynchronous web requests. Even today most of the challenging aspects of learning Javascript 5 years ago have been eased considerably, with the introduction of `async` functions and improved data types like `Map` and importing code in modules has helped with that.

Still today whenever I have to create a website for some project I'm working on I'm taken back by how complicated it can be to create something that for all intents and purposes should be much simpler. This is my experience in front-end and what I think you should know if you're starting to learn web development in 2020.

Starting off at a high level, I believe the job of web developer has 3 important roles. UI/UX designing - websites are only useful to humans if they can interact with them, different colours and font styles have emotional impacts on people, there's a reason that elevator buttons are in the order they are, or why all fast food restaurants have red theming. Software Engineering - It may seem diffuse but having a foundation in software engineering is different to knowing how to program, if you're designing a website for 10 people, you can do whatever you want, but if you're designing a website for 10,000 people, you need to know how to scale. Manager - Even if you're just a single developer working on a personal profile site knowing how to manage your resources is incredibly important, sure you can spend the entire weekend working to fix one small CSS issue on your site, but the reward from that effort might not be worth the time taken, you're time is valuable and you need to remember that. To be a great web developer you need these three skills, and you need to be proficient at them, and the only way that I know you can be proficient at any skills is to practice.

From a software engineering viewpoint there are several key technologies and concepts that you need to understand to be a proficient web developer. The internet has had a large influence on the evolution of JavaScript, 

```jsx
var xmlhttp;

if (window.XMLHttpRequest) {
    xmlhttp = new XMLHttpRequest();
		xmlhttp.addEventListener('load', handleEvent);
    xmlhttp.open("GET", filepath, false);
    xmlhttp.send(null);
}
```

```jsx
async function GetDataFromApi() {
	const data = await fetch("https://api.website.com/v1/important-data").json()
	const parsedData = data.map(item => {
			return ParseData(item)
	})
	return parsedData
}
```

- Event Loop
- Asynchronous Programming
- JavaScript
- TypeScript
- npm/node
- deno
- rendering
- react
- vue
- deployment
- git/ Version Management
- licensing
- Compilation/Interpretation/JIT

### Licensing

Code like any other human work is intellectual property. It's important to understand how licensing around computer code works so that you can protect your work, and so that you don't infringe on somebody else's work.

To start with, there are two main types of software licenses. Open source, and closed source. In open source software, the code is freely distributed by the author, depending specifically on the license you can copy it, study it, reimplement and build upon it, and use it in paid software.

There are lots of open source licenses, and you can create your own if you so wish. Some popular licenses include MIT, Apache 2.0, and GNU.

Closed source or proprietary software is where the owner of the code has not released the source code and has only made the executed binary available. Normally you must pay to run the code.

### Stack and Heap

```jsx
console.log("Aloha")

setTimeout(() => {
	console.log("Hello there sunshine")
}, 1000)

console.log("Greetings")
```

Quick note about computer memory, most people when they think about memory think about RAM or maybe the CPU cache. But the important concept that is not mentioned is that memory needs to be structured to be useful, every byte in memory can be accessed with its address written in hex `0x123456789`

There are two memory sections used in a computer, a stack and the heap. Memory in a stack structure can only be accessed in a specific order, you can only access what's at the top of the stack, you can add and remove memory pointers to a stack in push and pop operations respectively, this is known as Last In First Out (LIFO). The heap is a more unstructured data set, it's a place where programs can allocate memory for variables, objects, file descriptors, etc. 

### Garbage Collection

Unlike languages in the `C` family JavaScript will automatically reserve memory for you when you use it, and release the memory wen your finished. But how does it know that you've finished using memory? There are different strategies for memory management and dozens of books and journal articles have been written on the subject, but JavaScript uses a garbage collector which does exactly what it sounds like, when memory is devalidated the garbage collector releases the memory back to the operating system. It knows that memory is devalidated when the number of references pointing to the address reaches zero.

### Compilation, Interpretation, and JIT

Compilers in themselves are a huge field in computer science, there are university degrees and majors that specifically look at compilers so this section will be brief.

Computer languages like JavaScript are a great way to program instructions from a human perspective but computers can't actually run these commands. At the bare metal computers execute commands in machine code, which is a binary representation of a simple instruction set that CPUs are designed to use known as assembly languages. Each CPU vendor uses a different assembly language that have similar instructions. This is the reason why you can't run a program compiled for one CPU like say an Intel x86 on another CPU like a Snapdragon. Commands include setting registers in the CPU to specific values, addition, multiplication, subtraction, division, and jumping to name a few. Programming languages were invented as a way to encapsulate more complicated concepts into a simpler form.

```jsx
const x_list = ["a", "b", "c"]
if (x_list.includes("a")) {
	console.log(x_list[1])
}
```

This code on the onset looks fairly simple, it's defining a list and accessing values in the list based on if other values exist. The code only takes 4 lines, but the bytecode for this script is over 30000 lines long!

Bytecode is interesting, it's an attempt for a universal assembly language for a specific language. This bytecode is once again translated to machine code by a compiler or interpreter.

When code is written and then translated to assembly and then executed, the code is said to be compiled. When the code is written and then executed without being translated beforehand, this is known as interpretation, where a program called an interpreter will inspect each block of code and decide what assembly code will be used. However most high level languages like JavaScript sit somewhere in the middle with a concept known as Just-In-Time compilation. JIT is an extremely popular method of code execution, Android, Java, JavaScript, and Python (PyPy) all use JIT.

There are tradeoffs to all these different methods. Compilation is normally the most efficient method for translating code, this is because modern compilers have lots of different optimisation techniques like multiple passes and many different loop and memory optimisations, the problem with this is that it can take significant time and compute resources to optimise large programs, in fact some compilation problems are np-complete or undecidable.

Interpretation is a different approach, the idea behind interpretation is to translate the code into assembly as the code is being executed. The advantage to this is that there is no compile step, the code is simply run. But the disadvantage is there is minimal time for optimisation. So if you are doing something inefficiently your code will not be optimised.

JIT is a good compromise between these different approaches, in fact most languages today don't fall into the compilation or interpretation definitions. JIT turns this into a spectrum, there are languages which have both a compilation step and an interpretation step.

## References

[Memory Management](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management)