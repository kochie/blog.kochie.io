---
title: Building a Contact Tracing Platform
blurb:
  "Learn how to automate and build an application to trace exposures using
  Amazon's Cloud Development Kit (CDK)"
tags:
  - software
  - maths
author: kochie
jumbotron:
  src: omar-flores-MOO6k3RaiwE-unsplash.jpg
  alt: connections
publishedDate: 2021-05-05T09:00:00+10:00
---

> TLDR: I made a contact tracing website that you can access
> [here](https://ct.vercel.app)

### Table of Contents

# Introduction

Infrastructure as code is a a great way to manage the deployment and
maintainence of applications and the machines required to run. Writing
configurations for applications as code allows easy identitcal deployments and
testability. In this article I'm going to describe how to use the AWS Cloud
Development Kit (CDK) to create an application and deploy it to an AWS
environment.

AWS CDK is an open source framework to define cloud application resources. It's
avaliable in a number of languages including TypeScript, Golang, .Net, and Java,
and lets you develop the resources for your application in farmiliar languages
so your buisness doesn't need to learn a new one.

To show how easy it is to create an application with CDK I'g going to make
something topical. At the time of writing Melbourne is under it's 5th covid
related lockdown, one of the reasons given for the lockdown was that contact
tracing personnel were inundated with exposure sites which needed to be
contacted and their staff and visitors tested and their whereabouts traced. This
type of problem is well suited to an automated solution, so I figured, why don't
I try to build a contact tracing app?

<GithubProject repo="contact-tracing" owner="kochie" />

If you want to see any of the code I've written for this demo you can find it on
github.

# Architecture

## Backend

To start with, here is a basic architecture diagram of what were going to build.

![Backend Architecture Diagram](/articles/02-contact-tracing-part-1/ct-architecture.svg)

The backend architecture for this is quite simple, the system is based off of a
serverless architecture so its cost is proportional to the amount of use it
recieves. The API which will handle the contact tracing is managed through
Amazon AppSync a managed graphql service. Appsync is great because you can
update an API in realtime by just adding more data sources to fetch data for
queries, all you need to do is define a schema and where to fetch the data from
and you're mostly done. There are a few more steps if you want to define
authentication and more complicated data sources but for the post part it's plug
and play.

The checkin data for this applicaiton will be stored in Amazon DynamoDB. There
are a few reasons why I chose Dynamo, the first is that it's a fully managed
serverless product, so I don't have to worry about managing the service for the
most part. The second is that it's fast, I mean really fast, a standard query
takes about 5ms, that's pretty good (as we go on I'll talk about how I'm caching
a lot of the queries in Dynamo Dax but this didn't speed up most queries mor the
most part and I'll explain why later). The final reason is that the data can be
easily stored in dynamo as a key value pair. Each checkin looks something like
this example.

```json
{
  "location_id": "1",
  "user_id": "2",
  "checkin_datetime": "2021-06-01T00:00:00+10:00"
}
```

Super nice and simple, and it's really easy to search for a checkin based on the
time, user_id, and location_id. DynamoDB queries need a key to search upon and
can be refined using a "sort key", in the application I'm using the user_id and
location_id as "partition keys" while the date will be the sort key. To support
multiple pertition keys in Dynamo you need to have a GlobalSecondaryIndex.

Authentication is vital for real world services. Having the ability to verify
users who will access sensitive data (checkin data is Personal Identifying
Information [PII]) is absolutely needed. AppSync supports multiple simultaneous
authentication methods including API keys, IAM user signing, Amazon Cognito, and
external providers, for this demo I'm going to use Congnito. Amazon Cognito is a
managed authentication service which can store thousands of user credentials.

There are two components for the api in the `lib` directory, the `functions` and
the `schema`

### What is CDK?

The AWS CDK is a framework that can be used to define and organise resources on
the AWS cloud. Any project in CDK is setup using "stacks" which are individual
deployments that resources are grouped in, in actual fact CDK converts stacks
into Amazon CloudFormation templates and subsequently deploys the templates as
stacks in CloudFormation.

The CDK is avaliable in a bunch of different languages but for this demo I'm
going to use TypeScript to define the CDK stack.

> > I'm using CDK v2 is this demo because it's pretty close to being released
> > soon. CDK v2 has a bunch of improvements over the first version which you
> > can read about on the
> > [aws blog](https://docs.aws.amazon.com/cdk/latest/guide/work-with-cdk-v2.html)
> > but for this demo it won't matter too much which version you use.

The first thing to do is install the CDK tool, now if you're using another
language like Go or Java the installation will be a bit different but there are
instructions for each language on the CDK website.

```bash
npm install -g aws-cdk@next
```

After this you can create a new CDK project based off the app template as shown
below.

```bash
cdk init app --language typescript
```

After this you should have a blank CDK project, woo! To verify you should have a
directory layout similar to the screenshot below.

```none
.
├── README.md
├── bin
│   └── myapp.ts
├── cdk.json
├── jest.config.js
├── lib
│   └── myapp-stack.ts
├── package-lock.json
├── package.json
├── test
│   └── myapp.test.ts
└── tsconfig.json
```

### Defining the Schema

```graphql
# scalars.graphql

scalar AWSTimestamp
scalar AWSURL
scalar AWSDate
scalar AWSDateTime

directive @aws_api_key on FIELD_DEFINITION | INPUT_OBJECT | OBJECT | ENUM
directive @aws_cognito_user_pools on FIELD_DEFINITION | INPUT_OBJECT | OBJECT | ENUM_VALUE
```

```graphql
# schema.graphql

type CheckIn {
  location_id: String
  user_id: String
  checkin_datetime: AWSDateTime
}

type Output {
  items: [CheckIn]
  nextToken: String
}

type Exposures {
  users: [String]
  locations: [String]
}

type User {
  user_id: String
  contacts: [Location]
}

type Location {
  time: AWSDateTime
  location_id: String
  visitors: [User]
}

type LocationFlat {
  location_id: String
  latitude: String
  longitude: String
}

type Node {
  user_id: String
}

type Link {
  source: String
  target: String
  time: String
  location_id: String
  latitude: String
  longitude: String
}

type Flat {
  nodes: [Node]
  links: [Link]
  locations: [LocationFlat]
}

type Query {
  get_user_location_history(
    user_id: String!
    from: AWSDateTime
    until: AWSDateTime
    nextToken: String
    limit: Int
  ): Output
  get_location_attendees(
    location_id: String!
    from: AWSDateTime
    until: AWSDateTime
    nextToken: String
    limit: Int
  ): Output
  trace_exposure(
    user_id: String!
    from: AWSDateTime
    until: AWSDateTime
  ): Exposures
  trace_exposure_tree(
    user_id: String!
    from: AWSDateTime
    until: AWSDateTime
  ): User
  trace_exposure_flat(
    user_id: String!
    from: AWSDateTime
    until: AWSDateTime
  ): Flat
  trace_exposure_over_time(
    user_id: String!
    from: AWSDateTime
    until: AWSDateTime
    step: Int
    depth: Int
  ): [Flat]
}

type Mutation {
  check_in(location_id: String!, user_id: String!): CheckIn
}

type Schema {
  query: Query
  mutation: Mutation
}
```

### Writing the Functions

```go
package common

import (
	"context"
	"log"
	"os"
	"time"

	"github.com/aws/aws-dax-go/dax"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
	"github.com/aws/aws-xray-sdk-go/xray"
)

var client *dax.Dax

//var client *dynamodb.Client
var tableName = os.Getenv("TABLE_NAME")

type CheckIn struct {
	UserID          string    `dynamodbav:"user_id"`
	LocationID      string    `dynamodbav:"location_id"`
	CheckinDatetime time.Time `dynamodbav:"checkin_datetime"`
	Latitude        string    `dynamodbav:"latitude"`
	Longitude       string    `dynamodbav:"longitude"`
}

func GetLocationVisitors(locationId, from, until string, ctx context.Context) ([]*CheckIn, error) {
	log.Println("GetLocationVisitors")
	var expression string
	expressionAttributeValues := map[string]types.AttributeValue{
		":location_id": &types.AttributeValueMemberS{Value: locationId},
	}

	if from != "" && until != "" {
		expression = `location_id = :location_id AND checkin_datetime BETWEEN :from AND :until`
		expressionAttributeValues[":from"] = &types.AttributeValueMemberS{Value: from}
		expressionAttributeValues[":until"] = &types.AttributeValueMemberS{Value: until}
	} else if until != "" {
		expression = `location_id = :location_id AND checkin_datetime <= :until`
		expressionAttributeValues[":until"] = &types.AttributeValueMemberS{Value: until}
	} else if from != "" {
		expression = `location_id = :location_id AND checkin_datetime >= :from`
		expressionAttributeValues[":from"] = &types.AttributeValueMemberS{Value: from}
	} else {
		expression = `location_id = :location_id`
	}

	paginator := dynamodb.NewQueryPaginator(client, &dynamodb.QueryInput{
		TableName:                 aws.String(tableName),
		KeyConditionExpression:    aws.String(expression),
		ExpressionAttributeValues: expressionAttributeValues,
	})

	locations := make([]*CheckIn, 0)
	for paginator.HasMorePages() {
		resp, err := paginator.NextPage(ctx)

		if err != nil {
			return nil, err
		}

		for _, item := range resp.Items {
			checkin := CheckIn{}
			err := attributevalue.UnmarshalMap(item, &checkin)
			if err != nil {
				return nil, err
			}

			locations = append(locations, &checkin)
		}
	}

	return locations, nil
}
```

```go
package main

import (
	"context"
	"time"

	"github.com/aws/aws-lambda-go/lambda"
	"github.com/kochie/contact-tracing/lib/functions/common"
)

type User struct {
	UserId   string      `json:"user_id"`
	From     string      `json:"-"`
	Contacts []*Location `json:"contacts"`
}

type Location struct {
	Time       time.Time `json:"time"`
	LocationId string    `json:"location_id"`
	Visitors   []*User   `json:"visitors"`
}

func HandleRequest(ctx context.Context, event interface{}) (*User, error) {
	eventData := event.(map[string]interface{})
	arguments := eventData["arguments"].(map[string]interface{})
	userId := arguments["user_id"].(string)
	from := ""
	if _, ok := arguments["from"].(string); ok {
		from = arguments["from"].(string)
	}
	until := ""
	if _, ok := arguments["until"].(string); ok {
		until = arguments["until"].(string)
	}

	seenUsers := make(map[string]bool)
	seenLocations := make(map[string]bool)

	rootUser := User{UserId: userId, From: from, Contacts: make([]*Location, 0)}
	stack := []*User{&rootUser}

	for len(stack) > 0 {
		user := stack[0]
		from = user.From
		stack = stack[1:]

		if _, ok := seenUsers[user.UserId]; ok {
			continue
		}

		seenUsers[user.UserId] = true
		checkins, err := common.GetUserLocationHistory(user.UserId, from, until, ctx)
		if err != nil {
			return nil, err
		}
		for _, checkin := range checkins {
			locationID := checkin.LocationID
			if _, ok := seenLocations[locationID]; ok {
				continue
			}
			seenLocations[locationID] = true

			f := checkin.CheckinDatetime.Add(-time.Hour).Format(time.RFC3339)
			u := checkin.CheckinDatetime.Add(time.Hour).Format(time.RFC3339)
			visitors, err := common.GetLocationVisitors(locationID, f, u, ctx)
			if err != nil {
				return nil, err
			}

			users := make([]*User, 0)
			for _, visitor := range visitors {
				if _, ok := seenUsers[visitor.UserID]; ok {
					continue
				}

				u := User{visitor.UserID, checkin.CheckinDatetime.Format(time.RFC3339), make([]*Location, 0)}
				stack = append(stack, &u)
				users = append(users, &u)
			}

			user.Contacts = append(user.Contacts, &Location{
				checkin.CheckinDatetime,
				locationID,
				users,
			})
		}
	}

	return &rootUser, nil
}

func main() {
	lambda.Start(HandleRequest)
}
```

### Building the Stack

```typescript
import { aws_dynamodb as dynamo } from 'aws-cdk-lib'

const contact_table = new dynamo.Table(this, 'contact-tracing-table', {
  tableName: 'checkins',
  encryption: dynamo.TableEncryption.AWS_MANAGED,
  partitionKey: {
    name: 'location_id',
    type: dynamo.AttributeType.STRING,
  },
  sortKey: {
    name: 'checkin_datetime',
    type: dynamo.AttributeType.STRING,
  },
  billingMode: BillingMode.PAY_PER_REQUEST,
})

contact_table.addGlobalSecondaryIndex({
  indexName: 'index_by_user',
  partitionKey: {
    name: 'user_id',
    type: dynamo.AttributeType.STRING,
  },
  sortKey: {
    name: 'checkin_datetime',
    type: dynamo.AttributeType.STRING,
  },
})
```

```typescript
const user_pool = new cognito.UserPool(this, 'ct-user-pool', {
  userPoolName: 'contact-tracing-pool',
  signInCaseSensitive: false,
  selfSignUpEnabled: true,
  signInAliases: {
    email: true,
  },
  autoVerify: {
    email: true,
  },
  standardAttributes: {
    email: { required: true },
  },
  passwordPolicy: {
    requireSymbols: false,
    requireDigits: false,
    requireLowercase: false,
    requireUppercase: false,
  },
})

const user_pool_client = new cognito.UserPoolClient(
  this,
  'ct-user-pool-client',
  {
    userPool: user_pool,
    userPoolClientName: 'contact-tracing-client',
  }
)
```

```typescript
const api = new appsync.CfnGraphQLApi(this, 'ct-api', {
  authenticationType: 'AMAZON_COGNITO_USER_POOLS',
  name: 'contact-tracing-api',
  userPoolConfig: {
    userPoolId: user_pool.userPoolId,
    awsRegion: this.region,
    defaultAction: 'ALLOW',
  },
  logConfig: {
    cloudWatchLogsRoleArn:
      'arn:aws:iam::457234467265:role/service-role/appsync-graphqlapi-logs-ap-southeast-2',
    excludeVerboseContent: false,
    fieldLogLevel: 'ALL',
  },
})

const api_schema = new appsync.CfnGraphQLSchema(this, 'ct-api-schema', {
  apiId: api.attrApiId,
  definition: readFileSync(
    join(__dirname, 'graphql/schema.graphql')
  ).toString(),
})
```

```typescript
const table_role = new iam.Role(this, 'ItemsDynamoDBRole', {
  assumedBy: new iam.ServicePrincipal('appsync.amazonaws.com'),
})
table_role.addManagedPolicy(
  iam.ManagedPolicy.fromAwsManagedPolicyName('AmazonDynamoDBFullAccess')
)

const dataSource = new appsync.CfnDataSource(this, 'ItemsDataSource', {
  apiId: api.attrApiId,
  name: 'ItemsDynamoDataSource',
  type: 'AMAZON_DYNAMODB',
  dynamoDbConfig: {
    tableName: contact_table.tableName,
    awsRegion: this.region,
  },
  serviceRoleArn: table_role.roleArn,
})
```

```typescript
const dataSource = new appsync.CfnDataSource(this, 'ItemsDataSource', {
  apiId: api.attrApiId,
  name: 'ItemsDynamoDataSource',
  type: 'AMAZON_DYNAMODB',
  dynamoDbConfig: {
    tableName: contact_table.tableName,
    awsRegion: this.region,
  },
  serviceRoleArn: table_role.roleArn,
})
```

```typescript
const checkinResolver = new appsync.CfnResolver(
  this,
  'checkinMutationResolver',
  {
    apiId: api.attrApiId,
    typeName: 'Mutation',
    fieldName: 'check_in',
    dataSourceName: dataSource.name,
    requestMappingTemplate: `{
        "version": "2018-05-29",
        "operation": "PutItem",
        "key": {
          "location_id": $util.dynamodb.toDynamoDBJson($ctx.args.location_id),
          "checkin_datetime": $util.dynamodb.toDynamoDBJson($util.time.nowISO8601())
        },
        "attributeValues": {
          "user_id": $util.dynamodb.toDynamoDBJson($ctx.args.user_id)
        }
      }`,
    responseMappingTemplate: `$util.toJson($ctx.result)`,
  }
)
checkinResolver.addDependsOn(api_schema)
```

## Frontend

```bash
npx create-next-app frontend/
```

### Setting up Authentication

```typescript{8-12}
import React, { useEffect } from "react";
import type { AppProps } from 'next/app'
import { Auth } from "aws-amplify";
import { ApolloProvider } from "@apollo/client";
import { useApollo } from "../lib/apolloClient";
import "tailwindcss/tailwind.css";

Auth.configure({
  userPoolId: process.env.NEXT_PUBLIC_USERPOOL_ID,
  userPoolWebClientId: process.env.NEXT_PUBLIC_CLIENT_ID,
  region: process.env.NEXT_PUBLIC_REGION,
});

function App({ Component, pageProps }: AppProps) {
  const apolloClient = useApollo(pageProps.initialApolloState);

  return (
    <ApolloProvider client={apolloClient}>
      <Component {...pageProps} />
    </ApolloProvider>
  );
}

export default App;
```

### Setting up Apollo

```typescript{15,18-20}
import React, { useEffect } from "react";
import type { AppProps } from 'next/app'
import { Auth } from "aws-amplify";
import { ApolloProvider } from "@apollo/client";
import { useApollo } from "../lib/apolloClient";
import "tailwindcss/tailwind.css";

Auth.configure({
  userPoolId: process.env.NEXT_PUBLIC_USERPOOL_ID,
  userPoolWebClientId: process.env.NEXT_PUBLIC_CLIENT_ID,
  region: process.env.NEXT_PUBLIC_REGION,
});

function App({ Component, pageProps }: AppProps) {
  const apolloClient = useApollo(pageProps.initialApolloState);

  return (
    <ApolloProvider client={apolloClient}>
      <Component {...pageProps} />
    </ApolloProvider>
  );
}

export default App;
```

### Building a D3 Component

![](/articles/02-contact-tracing-part-1/tree.svg)

# Final Thoughts

This project was actually a lot more complicated then I first assumed it would
be, the fact that both Dynamo Dax and XRay didn't have support for Golangs
`aws-sdk-v2` really slowed down my development. The D3 charts also took a long
time to make, but once they started to work it was okay to iterate and improve.
